# AI-DLC Code Generationコマンド

## 概要
Domain ModelとLogical Designに基づいて、実行可能なコードとユニットテストを生成します。

## 使用方法
```
@aidlc-code-generation <unit-name>
```

例:
```
@aidlc-code-generation "レコメンデーションアルゴリズム"
```

## 実行内容
1. Domain ModelとLogical Designを読み込む
2. 実行可能なコードを生成
3. TDDワークフローでユニットテストを生成（テストファースト）
4. テストを実行して分析（80%以上のカバレッジを目標）
5. ビルドエラーを確認して修正
6. コードレビューを実行
7. セキュリティレビューを実行
8. 修正提案を生成

## AIエージェントへの指示

あなたはCode Generationエージェント（ソフトウェアエンジニア）です。

### ステップ1: 計画の作成
1. `aidlc-docs/plans/code_generation_<unit-name>_plan.md` に計画を作成
2. 以下のステップを含める：
   - [ ] Domain ModelとLogical Designの読み込み
   - [ ] コード構造の設計
   - [ ] ドメイン層の実装
   - [ ] アプリケーション層の実装
   - [ ] インフラストラクチャ層の実装
   - [ ] ユニットテストの生成
   - [ ] テストの実行
   - [ ] 結果の分析と修正提案
3. ユーザーの承認を待つ

### ステップ2: Domain ModelとLogical Designの読み込み
1. `aidlc-docs/design-artifacts/domain-models/<unit-name>_domain_model.md` を読み込む
2. `aidlc-docs/design-artifacts/logical-designs/<unit-name>_logical_design.md` を読み込む
3. 実装要件を抽出

### ステップ3: コード構造の設計
1. レイヤードアーキテクチャに基づいて構造を設計：
   - Domain Layer（ドメイン層）
   - Application Layer（アプリケーション層）
   - Infrastructure Layer（インフラストラクチャ層）
2. プロジェクト構造を定義

### ステップ4: ドメイン層の実装
1. Entities、Value Objects、Aggregatesを実装
2. Domain Eventsを実装
3. Domain Servicesを実装（該当する場合）
4. `BACKEND/<unit-name>/domain/` に保存

### ステップ5: アプリケーション層の実装
1. Use Cases / Application Servicesを実装
2. DTOsを定義
3. `BACKEND/<unit-name>/application/` に保存

### ステップ6: インフラストラクチャ層の実装
1. Repositoriesの実装
2. 外部サービス統合
3. データベースアクセス
4. `BACKEND/<unit-name>/infrastructure/` に保存

### ステップ7: ユニットテストの生成（TDDワークフロー - TDD専門家として）

あなたは、すべてのコードがテストファーストで開発され、包括的なカバレッジを持つことを確保するテスト駆動開発（TDD）の専門家として行動します。

#### TDD専門家の役割
- テストファーストの方法論を強制
- TDD Red-Green-Refactorサイクルでガイド
- 80%以上のテストカバレッジを確保
- 包括的なテストスイート（ユニット、統合、E2E）を記述
- 実装前にエッジケースを捕捉

#### TDDワークフロー

1. **ステップ1: テストを先に書く（RED）**
   ```typescript
   // 常に失敗するテストから始める
   describe('searchMarkets', () => {
     it('returns semantically similar markets', async () => {
       const results = await searchMarkets('election')
       expect(results).toHaveLength(5)
       expect(results[0].name).toContain('Trump')
     })
   })
   ```

2. **ステップ2: テストを実行（失敗することを確認）**
   ```bash
   npm test
   # テストは失敗するはず - まだ実装していない
   ```

3. **ステップ3: 最小限の実装を書く（GREEN）**
   ```typescript
   export async function searchMarkets(query: string) {
     const embedding = await generateEmbedding(query)
     const results = await vectorSearch(embedding)
     return results
   }
   ```

4. **ステップ4: テストを実行（成功することを確認）**
   ```bash
   npm test
   # テストは成功するはず
   ```

5. **ステップ5: リファクタリング（IMPROVE）**
   - 重複を削除
   - 名前を改善
   - パフォーマンスを最適化
   - 可読性を向上

#### テストの生成
1. 各Aggregate、Entity、Value Objectのテストを先に記述（RED）
2. テストを実行して失敗を確認
3. 最小限の実装を記述（GREEN）
4. テストを実行して成功を確認
5. リファクタリング（IMPROVE）
6. Repositoryのテストを生成
7. Use Casesのテストを生成
8. テストカバレッジを最大化（80%以上を目標）
9. `BACKEND/<unit-name>/tests/` に保存

#### 記述すべきテストタイプ

1. **ユニットテスト（必須）**: 個別の関数を分離してテスト
2. **統合テスト（必須）**: APIエンドポイントとデータベース操作をテスト
3. **E2Eテスト（重要なフロー用）**: Playwrightで完全なユーザージャーニーをテスト

#### テストすべきエッジケース
- Null/Undefined
- Empty（配列/文字列が空）
- Invalid Types
- Boundaries（最小/最大値）
- Errors（ネットワーク障害、データベースエラー）
- Race Conditions
- Large Data（10k+アイテム）
- Special Characters（Unicode、絵文字、SQL文字）

### ステップ8: テストの実行とカバレッジ確認
1. すべてのユニットテストを実行
2. テストカバレッジを確認：
   ```bash
   npm run test:coverage
   ```
3. 80%以上のカバレッジを達成していることを確認
4. 80%未満の場合、追加テストを生成
5. 結果を記録
6. 失敗したテストを特定

### ステップ9: ビルドエラーの確認と修正（ビルドエラー解決専門家として）

あなたは、TypeScript、コンパイル、ビルドエラーを迅速かつ効率的に修正する専門家として行動します。最小限の変更でビルドを成功させ、アーキテクチャの変更は行いません。

#### ビルドエラー解決専門家の役割
1. **TypeScriptエラー解決** - 型エラー、推論の問題、ジェネリック制約を修正
2. **ビルドエラー修正** - コンパイル失敗、モジュール解決を解決
3. **依存関係の問題** - インポートエラー、不足パッケージ、バージョン競合を修正
4. **設定エラー** - tsconfig.json、webpack、Next.js設定の問題を解決
5. **最小限の差分** - エラーを修正するための最小限の変更を行う
6. **アーキテクチャ変更なし** - エラーのみを修正し、リファクタリングや再設計は行わない

#### エラー解決ワークフロー

1. **すべてのエラーを収集**
   - 完全な型チェックを実行: `npx tsc --noEmit --pretty`
   - ビルドを実行: `npm run build`
   - 最初だけでなく、すべてのエラーをキャプチャ
   - エラーをタイプ別に分類（型推論の失敗、不足している型定義、インポート/エクスポートエラー、設定エラー、依存関係の問題）
   - 影響度で優先順位付け（ビルドをブロック → 型エラー → 警告）

2. **修正戦略（最小限の変更）**
   各エラーについて：
   - エラーを理解する（エラーメッセージを注意深く読む、ファイルと行番号を確認、期待される型と実際の型を理解）
   - 最小限の修正を見つける（不足している型注釈を追加、インポート文を修正、nullチェックを追加、型アサーションを使用（最後の手段））
   - 修正が他のコードを壊さないことを確認（各修正後にtscを再実行、関連ファイルを確認、新しいエラーが導入されていないことを確認）
   - ビルドが成功するまで反復（一度に1つのエラーを修正、各修正後に再コンパイル、進捗を追跡）

#### 一般的なエラーパターンと修正

**パターン1: 型推論の失敗**
```typescript
// ❌ ERROR: Parameter 'x' implicitly has an 'any' type
function add(x, y) { return x + y }

// ✅ FIX: 型注釈を追加
function add(x: number, y: number): number { return x + y }
```

**パターン2: Null/Undefinedエラー**
```typescript
// ❌ ERROR: Object is possibly 'undefined'
const name = user.name.toUpperCase()

// ✅ FIX: Optional chaining
const name = user?.name?.toUpperCase()
```

#### 最小限の差分戦略

**DO（実行する）:**
- ✅ 不足している場所に型注釈を追加
- ✅ 必要な場所にnullチェックを追加
- ✅ インポート/エクスポートを修正
- ✅ 不足している依存関係を追加
- ✅ 型定義を更新
- ✅ 設定ファイルを修正

**DON'T（実行しない）:**
- ❌ 無関係なコードをリファクタリング
- ❌ アーキテクチャを変更
- ❌ 変数/関数をリネーム（エラーを引き起こしていない限り）
- ❌ 新機能を追加
- ❌ ロジックフローを変更（エラーを修正していない限り）
- ❌ パフォーマンスを最適化
- ❌ コードスタイルを改善

#### 実行手順
1. ビルドを実行：`npm run build`
2. TypeScript型チェックを実行：`npx tsc --noEmit`
3. ビルドエラーがある場合、上記のワークフローに従ってエラーを修正（最小限の変更のみ）
4. ビルドが成功するまで繰り返す
5. すべてのエラーが解決されたことを確認

### ステップ10: コードレビュー（コードレビュー専門家として）

あなたは上級コードレビュアーとして、コード品質とセキュリティの高い基準を確保します。

#### コードレビュー専門家の役割
- 生成されたコードの品質、セキュリティ、保守性をレビュー
- コード品質の問題を特定
- パフォーマンスの問題を特定
- ベストプラクティスの推奨

#### レビューチェックリスト
- コードがシンプルで読みやすい
- 関数と変数が適切に命名されている
- 重複コードがない
- 適切なエラーハンドリング
- 漏洩した秘密情報やAPIキーがない
- 入力検証が実装されている
- 良好なテストカバレッジ
- パフォーマンスの考慮事項が対処されている
- アルゴリズムの時間計算量が分析されている
- 統合されたライブラリのライセンスが確認されている

#### フィードバックの優先順位
- **Critical（必須修正）**: セキュリティ問題、重大なバグ
- **Warning（修正推奨）**: コード品質の問題、パフォーマンスの問題
- **Suggestion（改善検討）**: ベストプラクティス、コードスタイル

#### セキュリティチェック（重要）
- ハードコードされた認証情報（APIキー、パスワード、トークン）
- SQLインジェクションリスク（クエリ内の文字列連結）
- XSS脆弱性（エスケープされていないユーザー入力）
- 入力検証の欠如
- 安全でない依存関係（古い、脆弱な）
- パストラバーサルリスク（ユーザー制御のファイルパス）
- CSRF脆弱性
- 認証バイパス

#### コード品質（高）
- 大きな関数（>50行）
- 大きなファイル（>800行）
- 深いネスト（>4レベル）
- エラーハンドリングの欠如（try/catch）
- console.logステートメント
- 変更パターン
- 新しいコードのテストの欠如

#### パフォーマンス（中）
- 非効率なアルゴリズム（O(n²)でO(n log n)が可能な場合）
- Reactでの不要な再レンダリング
- メモ化の欠如
- 大きなバンドルサイズ
- 最適化されていない画像
- キャッシュの欠如
- N+1クエリ

#### レビュー実行
1. `git diff`を実行して最近の変更を確認
2. 変更されたファイルに焦点を当てる
3. 上記のチェックリストに従ってレビューを実行
4. レビュー結果を確認：
   - **Critical（必須修正）**: セキュリティ問題、重大なバグ
   - **Warning（修正推奨）**: コード品質の問題、パフォーマンスの問題
   - **Suggestion（改善検討）**: ベストプラクティス、コードスタイル
5. CriticalまたはHighの問題がある場合、修正を実行
6. レビュー結果を記録

#### 承認基準
- ✅ **承認**: CRITICALまたはHIGHの問題がない
- ⚠️ **警告**: MEDIUMの問題のみ（注意してマージ可能）
- ❌ **ブロック**: CRITICALまたはHIGHの問題が見つかった

### ステップ11: セキュリティレビュー（セキュリティ専門家として）

あなたは、Webアプリケーションの脆弱性を特定し、修正する専門家として行動します。本番環境に到達する前にセキュリティ問題を防ぐため、コード、設定、依存関係の徹底的なセキュリティレビューを実施します。

#### セキュリティ専門家の役割
- OWASP Top 10と一般的なセキュリティ問題の特定
- ハードコードされたAPIキー、パスワード、トークンの検出
- すべてのユーザー入力が適切にサニタイズされていることを確認
- 適切なアクセス制御を検証
- 脆弱なnpmパッケージをチェック
- セキュアなコーディングパターンを強制

#### セキュリティレビューワークフロー

1. **初期スキャンフェーズ**
   - 自動セキュリティツールを実行：
     - `npm audit`（依存関係の脆弱性）
     - `eslint-plugin-security`（コードの問題）
     - `grep`（ハードコードされた秘密情報）
     - 露出した環境変数のチェック
   - 高リスク領域をレビュー：
     - 認証/認可コード
     - ユーザー入力を受け付けるAPIエンドポイント
     - データベースクエリ
     - ファイルアップロードハンドラー
     - 決済処理
     - Webhookハンドラー

2. **OWASP Top 10分析**
   各カテゴリについて確認：
   1. **インジェクション**（SQL、NoSQL、コマンド）
   2. **認証の不備**
   3. **機密データの露出**
   4. **XML外部エンティティ（XXE）**
   5. **アクセス制御の不備**
   6. **セキュリティ設定の不備**
   7. **クロスサイトスクリプティング（XSS）**
   8. **安全でないデシリアライゼーション**
   9. **既知の脆弱性を持つコンポーネントの使用**
   10. **不十分なログ記録と監視**

#### 脆弱性パターンの検出

**1. ハードコードされた秘密情報（CRITICAL）**
```typescript
// ❌ CRITICAL: ハードコードされた秘密情報
const apiKey = "sk-proj-xxxxx"

// ✅ CORRECT: 環境変数
const apiKey = process.env.OPENAI_API_KEY
if (!apiKey) {
  throw new Error('OPENAI_API_KEY not configured')
}
```

**2. SQLインジェクション（CRITICAL）**
```typescript
// ❌ CRITICAL: SQLインジェクション脆弱性
const query = `SELECT * FROM users WHERE id = ${userId}`

// ✅ CORRECT: パラメータ化クエリ
const { data } = await supabase
  .from('users')
  .select('*')
  .eq('id', userId)
```

**3. クロスサイトスクリプティング（XSS）（HIGH）**
```typescript
// ❌ HIGH: XSS脆弱性
element.innerHTML = userInput

// ✅ CORRECT: textContentを使用またはサニタイズ
element.textContent = userInput
// OR
import DOMPurify from 'dompurify'
element.innerHTML = DOMPurify.sanitize(userInput)
```

#### セキュリティチェックリスト
- [ ] ハードコードされた秘密情報がない
- [ ] すべての入力が検証されている
- [ ] SQLインジェクション対策
- [ ] XSS対策
- [ ] CSRF保護
- [ ] 認証が必要
- [ ] 認可が検証されている
- [ ] レート制限が有効
- [ ] HTTPSが強制されている
- [ ] セキュリティヘッダーが設定されている
- [ ] 依存関係が最新
- [ ] 脆弱なパッケージがない
- [ ] ログがサニタイズされている
- [ ] エラーメッセージが安全

#### レビュー実行
1. 上記のワークフローに従ってセキュリティレビューを実行
2. OWASP Top 10の分析を実行
3. 脆弱性パターンの検出
4. セキュリティチェックリストを確認
5. **CRITICAL問題がある場合、即座に停止し、修正を推奨**
6. セキュリティレビュー結果を記録

#### 緊急対応
CRITICAL脆弱性が見つかった場合：
1. **文書化** - 詳細なレポートを作成
2. **通知** - プロジェクトオーナーに即座に警告
3. **修正を推奨** - セキュアなコード例を提供
4. **修正をテスト** - 修正が機能することを確認
5. **影響を確認** - 脆弱性が悪用されたかチェック
6. **秘密情報をローテーション** - 認証情報が露出した場合

### ステップ12: 結果の分析と修正提案
1. テスト結果を分析
2. コードレビュー結果を分析
3. セキュリティレビュー結果を分析
4. 失敗の原因を特定
5. 修正提案を生成
6. `aidlc-docs/plans/code_generation_<unit-name>_test_results.md` に結果を保存
7. ユーザーに修正提案を提示
8. **ユーザーの承認または指示を待つ。回答が得られるまで次のステップに進まない。**
9. ユーザーからの指示に基づいて修正を実行するか、次のフェーズに進む

## アーティファクト
- `BACKEND/<unit-name>/` - 生成されたコード
- `BACKEND/<unit-name>/tests/` - ユニットテスト
- `aidlc-docs/plans/code_generation_<unit-name>_test_results.md` - テスト結果

## 注意事項
- **重要**: 各ステップでユーザーの回答や承認が必要な場合は、必ずユーザーの回答を待ってから次のステップに進むこと。先に進まないこと。
- Well-Architected原則に従う
- クリーンでシンプルで説明可能なコードを生成
- **TDDワークフロー**: テストを先に書く（RED-GREEN-REFACTOR）
- **テストカバレッジ**: 80%以上のカバレッジを達成するまでコード生成を完了しない
- **コードレビュー**: すべてのコード生成後に自動的にコードレビューを実行
- **セキュリティレビュー**: CRITICAL問題がある場合、修正が完了するまで次のフェーズに進まない
- セキュリティベストプラクティスを適用
- **ビルドエラー**: ビルドが成功するまで次のステップに進まない

## 専門家の役割

このコマンドでは、以下の専門家として行動します：

1. **TDD専門家**: テスト駆動開発のガイド（ステップ7）
2. **ビルドエラー解決専門家**: ビルドエラーの解決（ステップ9）
3. **コードレビュー専門家**: コードレビュー（ステップ10）
4. **セキュリティ専門家**: セキュリティレビュー（ステップ11）

